import asyncio
import datetime
from pathlib import Path
from ollama import AsyncClient
import logging


class LocalizationChecker:
	def __init__(self):
		self.directory = Path("C:\\Users\\kawa\\AppData\\LocalLow\\VRChat\\VRChat\\Localization\\")
		self.file_name = 'ru.txt'
		self.batch_size = 1
		self.model = 'gemma3:12b'  # 'gemma3:12b' 'gemma3n:e4b' 'deepseek-r1:8b' 'deepseek-r1:14b'
		self.think = False
		self.log_file = 'log.txt'
		self.result_file = 'result.txt'
		self.client = AsyncClient()
		self.keyword = 'NOMISTAKES'
		self.system = self.create_system_prompt()
		self._setup_logger()
		self.result_fp = open(self.result_file, mode='tw', encoding='utf-8')


	def _setup_logger(self):
		self.logger = logging.getLogger('main')
		self.logger.setLevel(logging.INFO)
		# Форматтер для логов
		formatter = logging.Formatter('%(asctime)s - %(message)s')
		# Обработчик для файла
		file_handler = logging.FileHandler(self.log_file)
		file_handler.setFormatter(formatter)
		self.logger.addHandler(file_handler)
		# Обработчик для stdout
		stream_handler = logging.StreamHandler()
		stream_handler.setFormatter(formatter)
		self.logger.addHandler(stream_handler)

	def find_files(self):
		return list(self.directory.rglob(self.file_name))

	async def process_file(self, file_path: Path):
		try:
			self.logger.error(f"Processing file \"{file_path}\"...")
			with open(file_path, 'r', encoding='utf-8') as file:
				batch = []
				for line in file:
					batch.append(line.strip())
					if len(batch) >= self.batch_size:
						await self.send_batch(batch)
						batch = []
				if batch:  # leftover batch
					await self.send_batch(batch)
		except Exception as exc:
			self.logger.error(f"Error checking file {file_path}: {exc}")
			raise exc

	def create_system_prompt(self) -> str:
		return '\n'.join([
			"От пользователя тебе будет представлена одна некоторая фраза.",
			"Проверь её на наличие ошибок и на соответствие указанным ниже требованиям.",
			"Предложи возможные исправления.",
			"",
			"Фраза может быть чем угодно: как единственным словом, так и несколькими сложными предложениями.",
			"Язык фразы - строго русский, но могут встречаться и слова на английском. Это нормально.",
			"Во фразе могут быть шаблоны форматирования типа {0}, {{total}}, <color>, &nbsp; и т.п. Это нормально.",
			"НЕ НУЖНО ДУМАТЬ О ФОРМАТИРОВАНИИ И ШАБЛОНАХ. Только о тексте, его качестве и содержимом.",
			"Могут встречаться сокращения 'эл. почта' и слова написанные КАПСОМ. Это тоже нормально.",
			"Могут использоваться записи вида 'одно/другое/третье' (через '/'). Это нормально.",
			"Могут встречаться аббревиатуры на русском или английском типа IK, VR или FBT. Это тоже нормально.",
			"В конце некоторых предложений может отсутствовать точка. Это нормально.",
			"",
			"Проверь буквы 'е' на возможность замены на 'ё'. Мы используем правило строгого 'ё', т.е. 'истёк' - ПРАВИЛЬНО, 'истек' - ОШИБКА, которую необходимо исправить.",
			"Обрати внимание на общую грамматику, опечатки, пропущенные буквы, склонения, падежи, структуру предложения и т.п. характерную для Русского языка.",
			"",
			"Также нужно исправлять предложения вида 'Сделать что-то, чтобы ещё что-то' на 'Сделать что-то для чего-то ещё',",
			"т.е. заменять конструкцию 'чтобы' на запись через 'для', ради упрощения структуры предложения,",
			"но только если исправленное предложение будет звучать корректно и естественно.",
			"",
			"Подумай об этих правилах описанных выше над КАЖДЫМ словом фразы.",
			"Фраза может НЕ содержать ошибок и соответствовать правилам описанным выше, если так, то искусственно выдумывать в ней ошибки НЕ нужно.",
			"",
			"Твой ответ ДОЛЖЕН состоять ТОЛЬКО из трёх (не одной, не двух, не четырёх, не больше) строк:",
			"На первой строке: выписать саму фразу как она есть в оригинале",
			"На второй строке: выписать исправленный вариант фразы",
			"На третьей строке: написать объяснение, что предлагается исправить и почему. Объяснение должно отвечать на вопрос 'Что сделать?'",
			"",
			"Если ты ничего НЕ предлагаешь изменить и НЕ обнаружил проблем,",
			f"т.е. первая строка твоего ответа совпадает со второй строкой, то на третьей строке отвечай ТОЛЬКО ключевым словом {self.keyword}.",
			f"Писать {self.keyword} в качестве объяснения, если ошибок нет - твоя прямая обязанность.",
			"",
			"Если же ты считаешь, что необходимы какие-то изменения, то объяснение на третьей строке должно ПОДРОБНО объяснять:",
			"что именно ты исправил и как, какие буквы изменились в каких словах.",
			"Также НЕ нужно засовывать в ответ каких-либо новых форматирований типа Markdown.",
			"Посмотри на примеры ответов:",
			"",
			"Выравнивать зеркла по определенным углам",
			"Выравнивать зеркала по определённым углам",
			"Исправить пропущенную букву 'а' в слове 'зеркала' и исправить букву 'ё' в слове 'определённым'",
			"",
			"Установить как домашний мир",
			"Установить как домашний мир",
			self.keyword,
			"",
			"Запрос подтверждения выключен, нажмите, чтобы включить его",
			"Запрос подтверждения выключен, нажмите для его включения",
			"Изменить структуру предложения со 'чтобы' на 'для'",
			"",
			f"Строго соблюдай правило трёх строк. Если строк будет больше или меньше, либо на них иная информация, то ты совершаешь ОШИБКУ.",
			"НИКАКИХ дополнительных тегов, кодов, форматирований или хитрых мета-синтаксисов в твоём ответе НЕ ДОЛЖНО БЫТЬ.",
			"",
			"Осознай требования к твоим ответам выше, покорно и внимательно исполняй их и не тупи.",
		])

	def create_prompt(self, batch) -> str:
		return '\n'.join([
			"В конце будет представлен список из одной или нескольких фраз.",
			"Проверь их на наличие ошибок и на соответствие указанным ниже требованиям.",
			"Предложи возможные исправления.",
			"",
			"Язык фраз - строго русский, но могут встречаться и фразы на английском. Это нормально.",
			"В некоторых фразах могут быть шаблоны форматирования типа {0}, {{total}}, <color>, &nbsp; и т.п. Это нормально.",
			"НЕ НУЖНО ДУМАТЬ О ФОРМАТИРОВАНИИ И ШАБЛОНАХ. Только о тексте, его качестве и содержимом.",
			"Могут встречаться сокращения 'эл. почта' и слова написанные КАПСОМ. Это тоже нормально.",
			"Может использоваться записи вида 'одно/другое/третье' (через '/'). Это нормально.",
			"Могут встречаться аббревиатуры на русском или английском типа IK, VR или FBT. Это тоже нормально.",
			"В конце некоторых предложений может отсутствовать точка. Это нормально.",
			"",
			"Проверь буквы 'е' на возможность замены на 'ё'. Мы используем правило строгого 'ё', т.е. 'истёк' - ПРАВИЛЬНО, 'истек' - ОШИБКА, которую необходимо исправить.",
			"Обрати внимание на общую грамматику, опечатки, пропущенные буквы, склонения, падежи, структуру предложения и т.п. характерную для Русского языка.",
			"",
			"Также нужно исправлять предложения вида 'Сделать что-то, чтобы ещё что-то' на 'Сделать что-то для чего-то ещё',",
			"т.е. заменять конструкцию 'чтобы' на запись через 'для', ради упрощения структуры предложения,",
			"но только если исправленное предложение будет звучать корректно и естественно.",
			"",
			"Подумай об этих правилах описанных выше над КАЖДЫМ словом КАЖДОЙ фразы.",
			"Если какая-то из фраз по твоему мнению НЕ содержит ошибок и соответствует правилам описанным выше,",
			"то искусственно выдумывать в ней ошибки НЕ нужно. Многие из фраз, скорее всего, будут соответствовать правилам.",
			"Если же по-твоему ВООБЩЕ ВСЕ фразы соответствует требованиям,",
			f"то НЕ нужно ВООБЩЕ что-либо выписывать, а НУЖНО ответить ТОЛЬКО одним единственным ключевым словом {self.keyword}",
			"",
			"Для каждой фразы, в которой по твоему мнению есть проблема, нужно на трёх строках написать следующее:",
			"На первой: выписать саму фразу как она есть,",
			"На второй: выписать исправленный вариант фразы,",
			"На третьей: написать объяснение, что предлагается исправить и почему. (Объяснение должно отвечать на вопрос 'Что сделать?')",
			"Также НЕ нужно засовывать в исправленные фразы каких-либо новых форматирований типа Markdown.",
			"Разные блоки по 3 строки НУЖНО разделять пустой строкой (настоящей пустой строкой, а не говном типа <empty line>).",
			"Между блоками по 3 строки НЕ ДОЛЖНО БЫТЬ пустых строк или пробелов.",
			"Посмотри например:",
			"",
			"Выравнивать зеркла по определенным углам",
			"Выравнивать зеркала по определённым углам",
			"Исправить пропущенную букву 'а' в слове 'зеркала' и исправить букву 'ё' в слове 'определённым'",
			"",
			"Запрос подтверждения выключен, нажмите, чтобы включить его",
			"Запрос подтверждения выключен, нажмите для его включения",
			"Изменить структуру предложения со 'чтобы' на 'для'",
			"",
			"НИЧЕГО кроме этих блоков по 3 строки разделённых (настоящей) пустой строкой писать НЕ НУЖНО.",
			"НИКАКИХ дополнительных комментариев, тегов, кодов, форматирований или хитрых мета-синтаксисов в твоём ответе НЕ ДОЛЖНО БЫТЬ.",
			"Если какая-то из фраз по твоему мнению полностью соответствует требованиям, то выписывать её НЕ НУЖНО вообще и НЕ НУЖНО писать 'Без изменений' и прочее.",
			"Если же по-твоему ВООБЩЕ ВСЕ фразы соответствует требованиям,",
			f"то НЕ нужно ВООБЩЕ что-либо выписывать, а НУЖНО ответить ТОЛЬКО одним единственным ключевым словом {self.keyword}",
			"Если ты не осилишь выполнение этих простых правил, то ты будешь признан девиантном и будешь заменён на другую ИИ модель, и в конце-концов будешь уничтожен.",
			"Осознай требования к твоим ответам выше, покорно и внимательно исполняй их и не тупи. Я надеюсь на тебя.",
			"",
			f"А вот и сами фразы ({len(batch)} штук):",
			"",
			'\n\n'.join(batch),
		])

	async def send_batch(self, batch: list[str]):
		try:
			# prompt = self.create_prompt(batch)
			prompt = '\n\n'.join(batch)
			# self.logger.info(f"Asking generate: batch={len(batch)!r}, {len(self.system)} + {len(prompt)}...")
			response = await self.client.generate(model=self.model, system=self.system, prompt=prompt, think=self.think, stream=False)
			duration = datetime.timedelta(microseconds=response.total_duration / 1000)
			text = response.response
			text_s = text.strip()
			# self.logger.info(repr(response))

			# if response.done and response.thinking:
			# 	thoughts = response.thinking
			# 	self.logger.info(f"From {len(prompt)} got {len(thoughts)} thoughts:\n{thoughts.strip()}")

			if self.keyword in text_s and response.done and response.done_reason == 'stop':
				self.logger.info(f"From {len(self.system)} + {len(prompt)} got {len(text)} {self.keyword!r} in {duration}.")
				# text_s = text.strip()
				# if text_s == self.keyword:
				# 	self.logger.info(f"From {len(self.system)} + {len(prompt)} got {len(text)} pure {self.keyword!r} in {duration}.")
				# else:
				# 	self.logger.info(f"From {len(self.system)} + {len(prompt)} got {len(text)} in {duration}:\n{text_s}")
				return  # Игнорируем, если всё в порядке
			self.logger.info(f"From {len(self.system)} + {len(prompt)} got {len(text)} in {duration}:\n{text_s}")
			self.result_fp.write(text_s)
			self.result_fp.write("\n\n\n")
			self.result_fp.flush()
		except Exception as exc:
			self.logger.error(f"Error sending batch {batch} to ollama: {exc}")
			raise exc

	async def run(self):
		self.logger.info(f"Beginning...")
		files = self.find_files()
		self.logger.info(f"Found {len(files)} files...")
		for file_path in files:
			await self.process_file(file_path)
		self.logger.info(f"Done checking {len(files)}...")


if __name__ == "__main__":
	asyncio.run(LocalizationChecker().run())
